<!DOCTYPE html>
<html lang="en">
<head>
<title>Maggie's Codes</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
*{
    box-sizing: border-box;
}

body {
    margin: 0;
}

/* Style the header */
.header {
    font-family: Arial, Helvetica, sans-serif;
    font-size: 25px;
    font-weight: bold;
    letter-spacing: 1.4px;
    background-color: #f1f1f1;
    padding: 10px;
    text-align: center;
}

H2 {
    font-family: Arial, Helvetica, sans-serif;
    font-size: 15px;
    font-weight: normal;
    letter-spacing: 1.2px;
    color: #009900;
}
tab2 { 
    padding-left: 2em; 
}
P {
    font-family: Arial, Helvetica, sans-serif;
    font-size: 15px;
    color: #555555;
    line-height: 1.5;
    letter-spacing: .25px;
}

/* Style the top navigation bar */
.topnav {
    font-family: Arial, Helvetica, sans-serif;
    font-size: 18px;
    font-weight: normal;
    letter-spacing: 1.2px;
    color: #000000;
    overflow: hidden;
    background-color: #f9f9f9;
}

/* Style the topnav links */
.topnav a {
    float: middle;
    display: block;
    color: #000000;
    text-align: center;
    padding: 14px 16px;
    text-decoration: none;
}

/* Change color on hover */
.topnav a:hover {
    background-color: #ddd;
    color: #009900;
}

/* Create three unequal columns that floats next to each other */
.column {
    float: left;
    padding: 10px;
}

/* Left and right column */
.column.side {
    width: 15%;
}

/* Middle column */
.column.middle {
    width: 75%;
}

/* Clear floats after the columns */
.row:after {
    content: "";
    display: table;
    clear: both;
}

/* Responsive layout - makes the three columns stack on top of each other instead of next to each other */
@media (max-width: 500px) {
    .column.side, .column.middle {
        width: 100%;
    }
}

.dropbtn {
    font-family: Arial, Helvetica, sans-serif;
    font-size: 12px;
    font-weight: normal;
    letter-spacing: 1.2px;
    background-color: #f9f9f9;
    border-bottom: solid 1px #f9f9f9;
    text-transform: uppercase;
    color: black;
    padding: 8px;
    font-size: 16px;
    border: none;
    cursor: pointer;
}

.dropdown {
    position: relative;
    display: inline-block;
}

.dropdown-content {
    display: none;
    position: absolute;
    background-color: #f9f9f9;
    min-width: 160px;
    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
    z-index: 1;
}

.dropdown-content a {
    font-family: Arial, Helvetica, sans-serif;
    font-size: 12px;
    font-weight: normal;
    letter-spacing: 1.2px;
    color: black;
    padding: 12px 16px;
    text-decoration: none;
    display: block;
}

.dropdown-content a:hover {background-color: #f1f1f1}

.dropdown:hover .dropdown-content {
    display: block;
}

.dropdown:hover .dropbtn {
    background-color: #3e8e41;
}

</style>
</head>
<body>

<div class="header">
  <h1>Maggie Cao </h1>
<p><div class="dropdown">
  <button class="dropbtn">Simple Functions</button>
  <div class="dropdown-content">
    <a href="Basic_Functions/compare_sorting.cpp">Compare Sorting</a> 
    <a href="Basic_Functions/subset.cpp">Subset </a> 
    <a href="Basic_Functions/dynamic.cpp">Dynamic Function example</a>
  </div>
</div></p>

<p><div class="dropdown">
  <button class="dropbtn">Google Code Jam</button>
  <div class="dropdown-content">
    <a href="https://code.google.com/codejam/contest/544101/dashboard"> Assignment Link </a> 
    <a href="Google_Code_Jam/Board.cpp">Board Class</a> 
    <a href="Google_Code_Jam/Board.h">Board Header File</a> 
    <a href="Google_Code_Jam/mainBoard.cpp">Board main driver</a> 
    <a href="Google_Code_Jam/reverse.cpp">Reverse</a> <br>
    <a href="Google_Code_Jam/AlienLanguage.cpp">Alien Language</a>
    <a href="Google_Code_Jam/Numbers.cpp">Numbers</a>
    <a href="Google_Code_Jam/MinimumScalarProduct.cpp">Minimum Scalar Product</a>
  </div>
</div></p>

<p><div class="dropdown">
  <button class="dropbtn">Systems Programming</button>
  <div class="dropdown-content">
    <a href="Systems_Programming/uniq.c">Uniq command</a>
    <a href="Systems_Programming/runsim.c">Running child processes</a>
    <a href="Systems_Programming/my_grep.c">Grep command</a>
    <a href="Systems_Programming/pipe.c">Pipe example</a>
    <a href="Systems_Programming/my_nohup.c">Signals </a>
  </div>
</div><p>

<p><div class="dropdown">
  <button class="dropbtn">Mirai Project </button>
  <div class="dropdown-content">
    <a href="MiraiSecurityProject.pdf">Mirai execution report</a>
  </div>
</div><p>

<p><div class="dropdown">
  <button class="dropbtn">Simple Shapes CNN </button>
  <div class="dropdown-content">
    <a href="Simple_Shapes_CNN/proposal.pdf">Neural Network Concept</a>
    <a href="Simple_Shapes_CNN/draw.txt">Drawing random shapes</a>
    <a href="Simple_Shapes_CNN/pickletestcats.txt">Creating pickle files</a>
    <a href="Simple_Shapes_CNN/merge_files.txt">Merging pickle files</a>
    <a href="Simple_Shapes_CNN/load_merged_files.txt">Pickle loader to CNN</a>
    <a href="Simple_Shapes_CNN/cnn_sobel_main.txt">Sobel Algorithm for Edge & Contour Detection</a>
    <a href="Simple_Shapes_CNN/save_pickle_images.txt">Reduce image size</a>
    <a href="Simple_Shapes_CNN/cnn_copy_sobel_test.txt">CNN loader</a>
    <a href="Simple_Shapes_CNN/cnn_sobel_inception.txt">CNN Inception</a>
    <a href="Simple_Shapes_CNN/test_model.txt">Test training model</a>
    <a href="Simple_Shapes_CNN/googlecloud_config_cnn.txt">Google Cloud Configuration</a> 
  </div>
</div><p>

</p>
</div>
</div>
<div class="topnav">
  <a href="index.html">Home</a>
  <a href="about_me.html">About Me</a>
  <a href="project_logs.html">Project Documentation</a>
  <a href="interests.html">Interests</a>
</div>
<div class="column middle">
  <div style="width:1000px;height:700px;line-height:1.2em;overflow:auto;padding:0px;">
  <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=windows-1250">
  <meta name="generator" content="PSPad editor, www.pspad.com">
  <title>Algorithms</title>
</head>
<body>
from __future__ import print_function<br>
import math <br>
<br>
#the array input needs to be already sorted<br>
def binary_search(array, start, end, key):<br>
    #count how many elements in file, each separated by line<br>
    mid = len(array)//2<br>
    # binary search the first half<br>
    if array[mid] is not key:<br>
        if key &lt; array[mid]:<br>
            return binary_search(array, array[0], array[mid-1], key)<br>
        # binary search the second half<br>
        elif key &gt; array[mid]:<br>
            return binary_search(array, array[mid+1], array[array.size()-1], key)<br>
    elif key == array[mid]:<br>
        return array[mid]<br>
    <br>
'''Knuth's algorithm for uniform binary search:<br>
    based on the idea that instead of having an upper bound,<br>
    a lower bound and a midpoint, we use two ptrs: current<br>
    position i and one for delta (rate of change)'''<br>
def uniform_binary_search(array, i, delta, key):<br>
    i = math.ceil(array.size()/2) #current position<br>
    m = math.floor(array.size()/2) #num of current records<br>
    if (key == array[i]):<br>
        return i<br>
    elif m is not 0: <br>
        if array[i] &gt; key: <br>
            i = i - math.ceil(m/2)<br>
            m = math.floor(m/2)<br>
            return uniform_binary_search(array, i, m, key)<br>
        else:<br>
            i = i + math.ceil(m/2)<br>
            m = math.floor(m/2)<br>
            return uniform_binary_search(array, i, m, key)<br>
        <br>
# but don't need to maintain the value of m at all, we<br>
# only need to refer to a short table of the various delta<br>
# to use at each evel of the tree, alg is reduced to a lookup table<br>
def delta_table(num, j):<br>
    delta = []<br>
    if j &gt;= 1 and j &lt;= math.floor(math.log(num[2])) + 2:<br>
        delta[j] = math.floor(num + math.pow(2, j-1))<br>
        j = j + 1<br>
        return delta[j-1]<br>
    return -1 #error<br>
<br>
def uniform_binary_search_delta(array, i, delta, key):<br>
    i = delta_table(array.size(), 0) - 1 #midpoint of array<br>
    d = 0<br>
    if key == array[i]:<br>
        return i<br>
    elif delta_table(array.size(), d) == 0:<br>
        return -1<br>
    else:<br>
        if array[i] &gt; key:<br>
            d = d + 1<br>
            i = i - delta_table(array.size(), d)<br>
        elif array[i] &lt; key:<br>
            d = d + 1<br>
            i = i + delta_table(array.size(), d)<br>
<br>
def factorial(n): #this is better in dynamic programming<br>
    if n == 1:<br>
        return 1<br>
    elif n &gt; 1:<br>
        return n*factorial(n-1)        <br>
    return -1<br>
<br>
def palidrome(word, start, end):<br>
    length = word.length()<br>
    if length == 0 or length == 1:<br>
        return True<br>
    if word[0] == word[length]:<br>
        return True    <br>
    return palidrome(word, start+1, end-1)<br>
<br>
'''<br>
algorithm from: https://www.khanacademy.org/computing/computer-science/algorithms/recursive-algorithms/a/computing-powers-of-a-number<br>
'''<br>
def powers_of_number(base, exponent):<br>
    if exponent == 0:<br>
        return 1<br>
    #return powers_of_number(base, exponent-1) * base #this takes too much time if the base and exponent are large<br>
    elif exponent%2 == 0 and exponent &gt; 0: #y=x&circ;(e/2)<br>
        print("even exponent")<br>
        return powers_of_number(base, exponent/2) * base  <br>
    '''elif exponent%2 == 1 and exponent &gt; 0:<br>
        return powers_of_number(base, exponent) * base<br>
    elif exponent &lt; 0:<br>
        return 1/powers_of_number(base, exponent) * base'''<br>
         <br>
<br>
def insertion_sort(array):<br>
    done = False<br>
    i =  1<br>
    while not done:<br>
        j = i <br>
        temp = array[i]<br>
        while temp &lt; array[j-1] and j &gt; 0:<br>
            array[j] = array[j-1]<br>
            j = j - 1<br>
        array[j] = temp #put it into position<br>
        i = i + 1<br>
        if i &gt;= len(array) or j &gt;= len(array):<br>
            done = True<br>
        <br>
def merge_sort(array):<br>
    if len(array) &gt; 1:<br>
        mid = len(array)//2<br>
        left_half = array[ :mid]<br>
        right_half = array[mid: ] <br>
        merge_sort(left_half)<br>
        merge_sort(right_half)<br>
        <br>
        left_index = 0   <br>
        right_index = 0<br>
        k = 0<br>
        while left_index &lt; len(left_half) and right_index &lt; len(right_half):<br>
            if left_half[left_index] &lt; right_half[right_index]:<br>
                array[k] = left_half[left_index]<br>
                left_index = left_index + 1<br>
            else: <br>
                array[k] = right_half[right_index]<br>
                right_index = right_index + 1<br>
            k = k + 1<br>
        #exhaused arrays:<br>
        #if left_index == len(left_half)-1:<br>
        while right_index &lt; len(right_half):<br>
            array[k] = right_half[right_index]<br>
            right_index = right_index + 1<br>
            k = k + 1<br>
                <br>
        #if right_index == len(right_half)-1:<br>
        while left_index &lt; len(left_half):<br>
            array[k] = left_half[left_index]<br>
            left_index = left_index + 1<br>
            k = k + 1<br>
<br>
'''<br>
uses left and right pointers to array elm to find correct partitioning <br>
locations separating partition index value <br>
'''<br>
def swap(array, left, right):<br>
    temp = array[left]<br>
    array[left] = array[right]<br>
    array[right] = temp<br>
    <br>
def partition(array, left, right):<br>
    mid = left + (right-left)/2<br>
    # make pivot the of array and swap it with leftmost elm<br>
    pivot = array[mid]<br>
    array[mid] = array[left]<br>
    array[left] = pivot<br>
    print("pivot in partition: ", pivot)<br>
    forward = left + 1<br>
    backward = right<br>
    done = False<br>
    # while forward &lt;= backward: doesn't work<br>
    while not done:<br>
        while forward &lt;= backward and array[forward] &lt;= pivot:<br>
           forward = forward + 1   <br>
        while array[backward] &gt;= pivot and backward &gt;= forward:<br>
           backward = backward - 1<br>
        # should stop at this point when they are improperly placed <br>
        # array[forward] &gt; pivot and when array[backward] &lt; pivot<br>
        if backward &lt; forward:<br>
            done = True #exit out of loop<br>
        #if forward &lt; backward:<br>
        else:<br>
            swap(array, forward, backward)<br>
            <br>
    # reach until they cross when backward &lt; forward<br>
    # swap backward and first to put mid back in partition position<br>
    swap(array, left, backward)<br>
    print ("array backward: ", backward)<br>
    # return backward index<br>
    return backward <br>
<br>
def quicksort(array, front, back):<br>
    if front &lt; back:<br>
        pivot_position = partition(array, front, back)<br>
        quicksort(array, front, pivot_position-1)<br>
        quicksort(array, pivot_position+1, back)<br>
<br>
if __name__ == '__main__':<br>
    array = [54,26,93,17,77,31,44,55,20]<br>
    print ("Original array:", array)<br>
    #quicksort(array, 0, len(array) - 1)<br>
    #print ("After quicksort: ", array)<br>
    #insertion_sort(array)<br>
    #merge_sort(array)<br>
    #print(array)<br>
    #print (powers_of_number(12, 6))<br>
    binary_search(array, 0, len(array), 31)<br></body>
</html>

</body>
</html>
