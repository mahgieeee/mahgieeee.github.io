<!DOCTYPE html>
<html lang="en">
<head>
<title>Maggie's Codes</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
*{
    box-sizing: border-box;
}

body {
    margin: 0;
}

/* Style the header */
.header {
    font-family: Arial, Helvetica, sans-serif;
    font-size: 25px;
    font-weight: bold;
    letter-spacing: 1.4px;
    background-color: #f1f1f1;
    padding: 10px;
    text-align: center;
}

H2 {
    font-family: Arial, Helvetica, sans-serif;
    font-size: 15px;
    font-weight: normal;
    letter-spacing: 1.2px;
    color: #009900;
}
tab2 { 
    padding-left: 2em; 
}
P {
    font-family: Arial, Helvetica, sans-serif;
    font-size: 15px;
    color: #555555;
    line-height: 1.5;
    letter-spacing: .25px;
}

/* Style the top navigation bar */
.topnav {
    font-family: Arial, Helvetica, sans-serif;
    font-size: 18px;
    font-weight: normal;
    letter-spacing: 1.2px;
    color: #000000;
    overflow: hidden;
    background-color: #f9f9f9;
}

/* Style the topnav links */
.topnav a {
    float: middle;
    display: block;
    color: #000000;
    text-align: center;
    padding: 14px 16px;
    text-decoration: none;
}

/* Change color on hover */
.topnav a:hover {
    background-color: #ddd;
    color: #009900;
}

/* Create three unequal columns that floats next to each other */
.column {
    float: left;
    padding: 10px;
}

/* Left and right column */
.column.side {
    width: 15%;
}

/* Middle column */
.column.middle {
    width: 75%;
}

/* Clear floats after the columns */
.row:after {
    content: "";
    display: table;
    clear: both;
}

/* Responsive layout - makes the three columns stack on top of each other instead of next to each other */
@media (max-width: 500px) {
    .column.side, .column.middle {
        width: 100%;
    }
}

.dropbtn {
    font-family: Arial, Helvetica, sans-serif;
    font-size: 12px;
    font-weight: normal;
    letter-spacing: 1.2px;
    background-color: #f9f9f9;
    border-bottom: solid 1px #f9f9f9;
    text-transform: uppercase;
    color: black;
    padding: 8px;
    font-size: 16px;
    border: none;
    cursor: pointer;
}

.dropdown {
    position: relative;
    display: inline-block;
}

.dropdown-content {
    display: none;
    position: absolute;
    background-color: #f9f9f9;
    min-width: 160px;
    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
    z-index: 1;
}

.dropdown-content a {
    font-family: Arial, Helvetica, sans-serif;
    font-size: 12px;
    font-weight: normal;
    letter-spacing: 1.2px;
    color: black;
    padding: 12px 16px;
    text-decoration: none;
    display: block;
}

.dropdown-content a:hover {background-color: #f1f1f1}

.dropdown:hover .dropdown-content {
    display: block;
}

.dropdown:hover .dropbtn {
    background-color: #3e8e41;
}

</style>
</head>
<body>

<div class="header">
  <h1>Maggie Cao </h1>
<p><div class="dropdown">
  <button class="dropbtn">Simple Functions</button>
  <div class="dropdown-content">
    <a href="Basic_Functions/compare_sorting.cpp">Compare Sorting</a> 
    <a href="Basic_Functions/subset.cpp">Subset </a> 
    <a href="Basic_Functions/dynamic.cpp">Dynamic Function example</a>
  </div>
</div></p>

<p><div class="dropdown">
  <button class="dropbtn">Google Code Jam</button>
  <div class="dropdown-content">
    <a href="https://code.google.com/codejam/contest/544101/dashboard"> Assignment Link </a> 
    <a href="Google_Code_Jam/Board.cpp">Board Class</a> 
    <a href="Google_Code_Jam/Board.h">Board Header File</a> 
    <a href="Google_Code_Jam/mainBoard.cpp">Board main driver</a> 
    <a href="Google_Code_Jam/reverse.cpp">Reverse</a> <br>
    <a href="Google_Code_Jam/AlienLanguage.cpp">Alien Language</a>
    <a href="Google_Code_Jam/Numbers.cpp">Numbers</a>
    <a href="Google_Code_Jam/MinimumScalarProduct.cpp">Minimum Scalar Product</a>
  </div>
</div></p>

<p><div class="dropdown">
  <button class="dropbtn">Systems Programming</button>
  <div class="dropdown-content">
    <a href="Systems_Programming/uniq.c">Uniq command</a>
    <a href="Systems_Programming/runsim.c">Running child processes</a>
    <a href="Systems_Programming/my_grep.c">Grep command</a>
    <a href="Systems_Programming/pipe.c">Pipe example</a>
    <a href="Systems_Programming/my_nohup.c">Signals </a>
  </div>
</div><p>

<p><div class="dropdown">
  <button class="dropbtn">Mirai Project </button>
  <div class="dropdown-content">
    <a href="MiraiSecurityProject.pdf">Mirai execution report</a>
  </div>
</div><p>

<p><div class="dropdown">
  <button class="dropbtn">Simple Shapes CNN </button>
  <div class="dropdown-content">
    <a href="Simple_Shapes_CNN/proposal.pdf">Neural Network Concept</a>
    <a href="Simple_Shapes_CNN/draw.txt">Drawing random shapes</a>
    <a href="Simple_Shapes_CNN/pickletestcats.txt">Creating pickle files</a>
    <a href="Simple_Shapes_CNN/merge_files.txt">Merging pickle files</a>
    <a href="Simple_Shapes_CNN/load_merged_files.txt">Pickle loader to CNN</a>
    <a href="Simple_Shapes_CNN/cnn_sobel_main.txt">Sobel Algorithm for Edge & Contour Detection</a>
    <a href="Simple_Shapes_CNN/save_pickle_images.txt">Reduce image size</a>
    <a href="Simple_Shapes_CNN/cnn_copy_sobel_test.txt">CNN loader</a>
    <a href="Simple_Shapes_CNN/cnn_sobel_inception.txt">CNN Inception</a>
    <a href="Simple_Shapes_CNN/test_model.txt">Test training model</a>
    <a href="Simple_Shapes_CNN/googlecloud_config_cnn.txt">Google Cloud Configuration</a> 
  </div>
</div><p>

</p>
</div>
</div>
<div class="topnav">
  <a href="index.html">Home</a>
  <a href="about_me.html">About Me</a>
  <a href="project_logs.html">Project Documentation</a>
  <a href="interests.html">Interests</a>
</div>
<div class="column middle">
  <div style="width:1000px;height:700px;line-height:1.2em;overflow:auto;padding:0px;">
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title></title>
  </head>
  <body>
    from __future__ import print_function from __future__ import division import math #the array
    input needs to be already sorted def binary_search(array, start, end, key): if end &gt;= 1: mid
    = start + (end-start)//2 if array[mid] is key: return mid elif array[mid] &gt; key: return
    binary_search(array, start, mid-1, key) # binary search the second half elif array[mid] &lt;
    key: return binary_search(array, mid+1, end, key) return -1 #point where key is not present in
    the array anymore '''Knuth's algorithm for uniform binary search: based on the idea that
    instead of having an upper bound, a lower bound and a midpoint, we use two ptrs: current
    position i and one for delta (rate of change)''' def uniform_binary_search(array, i, delta,
    key): i = math.ceil(array.size()/2) #current position m = math.floor(array.size()/2) #num of
    current records if (key == array[i]): return i elif m is not 0: if array[i] &gt; key: i = i -
    math.ceil(m/2) m = math.floor(m/2) return uniform_binary_search(array, i, m, key) else: i = i +
    math.ceil(m/2) m = math.floor(m/2) return uniform_binary_search(array, i, m, key) # but don't
    need to maintain the value of m at all, we # only need to refer to a short table of the various
    delta # to use at each evel of the tree, alg is reduced to a lookup table def delta_table(num,
    j): delta = [] if j &gt;= 1 and j &lt;= math.floor(math.log(num[2])) + 2: delta[j] =
    math.floor(num + math.pow(2, j-1)) j = j + 1 return delta[j-1] return -1 #error def
    uniform_binary_search_delta(array, i, delta, key): i = delta_table(array.size(), 0) - 1
    #midpoint of array d = 0 if key == array[i]: return i elif delta_table(array.size(), d) == 0:
    return -1 else: if array[i] &gt; key: d = d + 1 i = i - delta_table(array.size(), d) elif
    array[i] &lt; key: d = d + 1 i = i + delta_table(array.size(), d) def factorial(n): #this is
    better in dynamic programming if n == 1: return 1 elif n &gt; 1: return n*factorial(n-1) return
    -1 def palidrome(word, start, end): length = word.length() if length == 0 or length == 1:
    return True if word[0] == word[length]: return True return palidrome(word, start+1, end-1) '''
    If n is even, then x^n = (x^2)^(n/2) If n is odd, then x^n = x * (x^2)^((n-1)/2) ''' def
    powers_of_number(base, exponent): if exponent == 0: return 1 #return powers_of_number(base,
    exponent-1) * base #this takes too much time if the base and exponent are large elif exponent%2
    == 0 and exponent &gt; 0: print("even") return powers_of_number(base*base, exponent/2) elif
    exponent%2 == 1 and exponent &gt; 0: print("odd") return powers_of_number(base*base,
    (exponent-1)/2) * base elif exponent &lt; 0: return powers_of_number(base, exponent+1)/base def
    insertion_sort(array): done = False i = 1 while not done: j = i temp = array[i] while temp &lt;
    array[j-1] and j &gt; 0: array[j] = array[j-1] j = j - 1 array[j] = temp #put it into position
    i = i + 1 if i &gt;= len(array) or j &gt;= len(array): done = True def merge_sort(array): if
    len(array) &gt; 1: mid = len(array)//2 left_half = array[ :mid] right_half = array[mid: ]
    merge_sort(left_half) merge_sort(right_half) left_index = 0 right_index = 0 k = 0 while
    left_index &lt; len(left_half) and right_index &lt; len(right_half): if left_half[left_index]
    &lt; right_half[right_index]: array[k] = left_half[left_index] left_index = left_index + 1
    else: array[k] = right_half[right_index] right_index = right_index + 1 k = k + 1 #exhaused
    arrays: #if left_index == len(left_half)-1: while right_index &lt; len(right_half): array[k] =
    right_half[right_index] right_index = right_index + 1 k = k + 1 #if right_index ==
    len(right_half)-1: while left_index &lt; len(left_half): array[k] = left_half[left_index]
    left_index = left_index + 1 k = k + 1 ''' uses left and right pointers to array elm to find
    correct partitioning locations separating partition index value ''' def swap(array, left,
    right): temp = array[left] array[left] = array[right] array[right] = temp def partition(array,
    left, right): mid = left + (right-left)//2 # make pivot the of array and swap it with leftmost
    elm pivot = array[mid] array[mid] = array[left] array[left] = pivot print("pivot in partition:
    ", pivot) forward = left + 1 backward = right done = False # while forward &lt;= backward:
    doesn't work while not done: while forward &lt;= backward and array[forward] &lt;= pivot:
    forward = forward + 1 while array[backward] &gt;= pivot and backward &gt;= forward: backward =
    backward - 1 # should stop at this point when they are improperly placed # array[forward] &gt;
    pivot and when array[backward] &lt; pivot if backward &lt; forward: done = True #exit out of
    loop #if forward &lt; backward: else: swap(array, forward, backward) # reach until they cross
    when backward &lt; forward # swap backward and first to put mid back in partition position
    swap(array, left, backward) print ("array backward: ", backward) # return backward index return
    backward def quicksort(array, front, back): if front &lt; back: pivot_position =
    partition(array, front, back) quicksort(array, front, pivot_position-1) quicksort(array,
    pivot_position+1, back) if __name__ == '__main__': array = [54,26,93,17,77,31,44,55,20] print
    ("Original array:", array) quicksort(array, 0, len(array) - 1) print ("After quicksort: ",
    array) #insertion_sort(array) #merge_sort(array) #print(array) #print (powers_of_number(2, -1))
    print (binary_search(array, 0, len(array)-1, 31))
  </body>
</html>

</body>
</html>
